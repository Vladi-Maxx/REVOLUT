# Ръководство за кода в Revolut Dashboard

## Принципи на разработка

Приложението следва няколко ключови принципа на разработка:

1. **Принцип за единична отговорност (SRP)**
   - Всеки клас има само една причина да се променя
   - Отделните функционалности са разделени в различни модули
   - Пример: `CsvImporter` отговаря само за импортиране на CSV, а не за визуализация на данни

2. **Модулност**
   - Компонентите са слабо свързани помежду си
   - Всеки компонент може да се тества самостоятелно
   - Разделяне на слоеве: UI компоненти, бизнес логика, достъп до данни

3. **Dependency Injection**
   - Компонентите получават своите зависимости чрез конструктора
   - Намалява твърдото обвързване между класовете
   - Улеснява тестването и замяната на имплементации

4. **Минимално използване на глобални състояния**
   - Всеки компонент управлява собственото си състояние
   - Комуникацията става чрез специфични интерфейси и callback функции

## Организация на кода

### Структура на директориите

```
/src
  /components - UI компоненти (графики, таблици, и др.)
  /services - Комуникация с външни услуги (Supabase)
  /utils - Помощни класове и функции
  /views - Основни изгледи на приложението
  app.js - Входна точка на приложението
```

### Именуване на файлове
- Файловете с класове използват PascalCase: `ChartComponent.js`
- Utility модули използват camelCase: `dataUtils.js`
- Всички файлове имат .js разширение

## Стандарти за кода

### Форматиране
- Отстъп: 4 интервала
- Максимална дължина на ред: ~100 символа
- Блоковете се ограждат с къдрави скоби на същия ред

### Именуване
- **Класове**: PascalCase (`ChartComponent`)
- **Методи и функции**: camelCase (`applyFilters`)
- **Променливи**: camelCase (`filteredTransactions`)
- **Константи**: UPPER_SNAKE_CASE (`DEFAULT_CURRENCY`)
- **Приватни полета**: с префикс "_" (`_transactions`)

### Документация
- Всеки клас има описателен коментар за неговата цел
- Методите са документирани с JSDoc коментари
- Сложни алгоритми трябва да бъдат обяснени с коментари

Пример:
```javascript
/**
 * Филтрира транзакции по зададени критерии
 * @param {Array} transactions - Масив с транзакции
 * @param {Object} filters - Обект с филтри
 * @returns {Array} Филтрирани транзакции
 */
filterTransactionsLocally(transactions, filters) {
    // Код
}
```

## Справочник на основните методи

### DashboardView
- `constructor()` - Инициализира основния изглед и всички компоненти
- `loadData()` - Зарежда данни от Supabase
- `applyFilters()` - Прилага текущите филтри върху данните
- `updateComponents()` - Обновява всички UI компоненти с новите данни

### FilterManager
- `initFilters()` - Инициализира филтрите с начални стойности
- `applyFilters(allTransactions)` - Прилага филтри върху транзакции
- `setupDateInputListeners()` - Настройва слушатели за полетата за дати
- `groupTransactionsByMerchant(transactions)` - Групира транзакции по търговци
- `updateChart(merchantsData)` - Подготвя данни за графика

### CsvImporter
- `importCsvFile(file)` - Обработва CSV файл и извлича транзакции
- `findUniqueTransactions(transactions)` - Премахва дублирани транзакции
- `createTransactionKey(transaction)` - Създава уникален ключ за транзакция
- `normalizeDate(dateString)` - Нормализира формата на датата

### ChartComponent
- `initChart(merchantsData)` - Инициализира графика с данни за търговци
- `updateChart(merchantsData)` - Обновява съществуваща графика с нови данни
- `generateColors(count)` - Генерира палитра от цветове за графиката

### MerchantsTableComponent
- `updateTable(merchantsData)` - Обновява таблицата с търговци
- `clearTable()` - Изчиства съдържанието на таблицата

### SummaryComponent
- `updateStats(stats)` - Обновява обобщените статистики

### DataUtils
- `formatAmount(amount, currency)` - Форматира суми с валута
- `calculateTransactionStats(transactions)` - Изчислява статистики за транзакции
- `groupTransactionsByMerchant(transactions)` - Групира транзакции по търговци

## Събития и слушатели

### DOM събития
- `DOMContentLoaded` - Инициализира приложението
- `click` на бутон за филтриране - Задейства `applyFilters()`
- `change` на полета за дати - Обновява филтрите
- `click` на бутони за бързи филтри - Задава предефинирани периоди

### Callback функции
- `onFilterSuccess` - Извиква се след успешно филтриране
- `notificationCallback` - Показва съобщения на потребителя

## Работа с асинхронни операции

Приложението използва Promise и async/await за асинхронни операции:

```javascript
async applyFilters() {
    try {
        // Извършва асинхронни операции
        const result = await this.filterManager.applyFilters();
        // Обработка на успешен резултат
    } catch (error) {
        // Обработка на грешка
        console.error('Грешка при прилагане на филтрите:', error);
    }
}
```

## Дебъгване и логове

При разработка използвайте структурирани логове за по-лесно дебъгване:

```javascript
console.log('FilterManager: Прилагане на филтри', {
    startDate: filters.startDate,
    endDate: filters.endDate,
    currency: filters.currency
});
```

За производствена среда премахнете излишните логове, за да подобрите производителността.

## Разработка на нови функционалности

1. **Първо проектирайте** - Помислете за отговорностите и взаимодействията
2. **Разделяйте на модули** - Създавайте малки, фокусирани компоненти
3. **Използвайте съществуващите абстракции** - Не преоткривайте колелото
4. **Пишете документация** - Документирайте важните решения и API
5. **Тествайте промените** - Уверете се, че новите функционалности работят правилно

## Проблеми и решения

### Кеширане на браузъра
При разработка може да имате проблеми с кеширане на JavaScript файлове.
Решения:
- Използвайте Hard Refresh (`Ctrl+Shift+R` / `Cmd+Shift+R`)
- Отворете Dev Tools и активирайте "Disable cache" в раздел Network
- Използвайте приватен/инкогнито режим на браузъра

### Асинхронно зареждане
Ако имате проблеми с асинхронното зареждане на данни:
- Използвайте await/async за последователно изпълнение
- Добавете индикатори за зареждане
- Проверявайте дали данните са налични преди манипулация
