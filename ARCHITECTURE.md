# Архитектура на приложението Revolut Dashboard

## Обща архитектура

Приложението следва модулна архитектура с ясно разделение на отговорностите между компонентите, базирана на следните архитектурни принципи:

1. **Принцип за единична отговорност (SRP)** - Всеки клас има точно една причина да се променя и добре дефинирана отговорност
2. **Разделяне на слоеве** - Ясно разделение между UI компоненти, бизнес логика и достъп до данни
3. **Dependency Injection** - Компонентите получават зависимостите си чрез конструктора

```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│   Sources   │────▶│    Core     │────▶│     UI      │
└─────────────┘     └─────────────┘     └─────────────┘
 CSV, Supabase      Data processing     Components, Views
```

## Компонентна диаграма

Приложението е изградено от следните основни компоненти, които взаимодействат помежду си:

```
┌─────────────────────────────────────────────────────────────────────────┐
│                             DashboardView                               │
└───────────────────────────────────┬─────────────────────────────────────┘
                                    │
                                    │ инициализира и управлява
                                    ▼
┌─────────────┐  ┌───────────────┐  ┌───────────────┐  ┌──────────────────┐
│ CsvImporter │  │ FilterManager │  │SupabaseService│  │QuickFilterManager│
└──────┬──────┘  └───────┬───────┘  └───────┬───────┘  └────────┬─────────┘
       │                 │                  │                    │
       │                 │                  │                    │
       │                 │                  │                    │
       │                 │                  │                    │
┌──────▼──────┐  ┌───────▼───────┐  ┌───────▼───────┐  ┌────────▼─────────┐
│  DataUtils  │  │ChartComponent │  │MerchantsTable │  │ SummaryComponent │
└─────────────┘  └───────────────┘  └───────────────┘  └──────────────────┘
```

## Поток на данните

### 1. Начално зареждане на данни
- При инициализация `DashboardView` прави заявка към `SupabaseService` за зареждане на данни
- Данните се съхраняват в `DashboardView` и се предават на `FilterManager`
- `FilterManager` подготвя филтрите и прилага начални настройки
- UI компонентите се обновяват с първоначалните данни

### 2. Филтриране на данни
- Потребителят задава филтри чрез интерфейса
- `FilterManager` прилага избраните филтри върху данните
- Филтрираните данни се групират по търговци и категории
- Резултатите се предават на UI компонентите чрез callbacks

### 3. Импортиране на данни
- Потребителят избира CSV файл за импортиране
- `CsvImporter` обработва файла и извлича транзакциите
- Проверява се за дублирани транзакции
- Новите транзакции се запазват в Supabase чрез `SupabaseService`
- UI компонентите се обновяват с новите данни

### 4. Категоризация
- Потребителят управлява категории чрез `CategoriesComponent`
- Асоциира търговци с категории чрез интерфейса
- Данните за категории се съхраняват в Supabase
- При преглед на графики, данните се групират по категории

## База данни

### Структура на базата данни

#### Таблица: transactions
- **Type** (String) - Тип на транзакцията
- **Product** (String) - Използван продукт
- **Started Date** (String) - Начална дата
- **Completed Date** (String) - Крайна дата
- **Description** (String) - Описание на транзакцията/име на търговеца
- **Amount** (Float) - Сума на транзакцията
- **Fee** (Float) - Такса (ако има)
- **Currency** (String) - Валута
- **State** (String) - Състояние на транзакцията
- **Balance** (Float) - Баланс след транзакцията

#### Таблица: categories
- **id** (bigint) - Първичен ключ
- **name** (Text) - Име на категорията
- **description** (Text) - Описание на категорията
- **color** (Text) - Цвят за визуализация
- **created_at** (Timestamp) - Дата на създаване

#### Таблица: merchant_categories
- **id** (bigint) - Първичен ключ
- **merchant_name** (Text) - Име на търговеца
- **category_id** (bigint) - Външен ключ към категория
- **created_at** (Timestamp) - Дата на създаване

### Схема на релациите

```
┌───────────────┐      ┌──────────────────────┐      ┌───────────────┐
│  transactions │      │  merchant_categories  │      │  categories   │
├───────────────┤      ├──────────────────────┤      ├───────────────┤
│ id            │      │ id                   │      │ id            │
│ Description   │◄─────┤ merchant_name        │      │ name          │
│ Amount        │      │ category_id          ├─────►│ description   │
│ Currency      │      │ created_at           │      │ color         │
│ Started Date  │      └──────────────────────┘      │ created_at    │
│ ...           │                                    └───────────────┘
└───────────────┘
```

## Основни класове и тяхната функционалност

### DashboardView
Основен контролер на приложението, който:
- Инициализира всички компоненти
- Координира комуникацията между компонентите
- Управлява жизнения цикъл на приложението
- Обработва потребителски събития

```javascript
// Пример за инициализация на компоненти в DashboardView
this.filterManager = new FilterManager({
    elements: { /* ... */ },
    supabaseService: supabaseService,
    dataUtils: DataUtils,
    notificationCallback: this.showNotification.bind(this),
    onFilterSuccess: (result) => {
        // Обновяване на UI компонентите при промяна на филтрите
        if (result && result.success) {
            // ...
        }
    }
});
```

### FilterManager
Отговаря за управлението на филтрите и филтрирането на данните:
- Инициализира филтрите с начални стойности
- Прилага филтрите към данните
- Известява другите компоненти при промяна на филтрите
- Подготвя данните за визуализация

### CsvImporter
Отговаря за импортирането на CSV файлове:
- Парсва CSV файловете 
- Нормализира данните
- Идентифицира уникални транзакции
- Добавя нови транзакции към съществуващите

### ChartComponent
Визуализира данните в графичен формат:
- Инициализира графиката с Chart.js
- Обновява графиката при промяна на данните
- Предоставя интерактивност на графиката

### CategoryChartComponent
Визуализира данните по категории:
- Групира транзакции по категории
- Показва разпределение на разходите
- Позволява интерактивен избор на категория

### MerchantsTableComponent
Показва таблица с търговци:
- Извежда обобщена информация за всеки търговец
- Поддържа сортиране по различни критерии
- Позволява избор на търговец за детайлен преглед

### CategoriesComponent
Управлява категории и техните асоциации:
- Създаване, редактиране и изтриване на категории
- Асоцииране на търговци с категории
- Визуализация на категоризираните данни

### SupabaseService
Обслужва комуникацията с бекенда:
- Извлича данни от Supabase
- Съхранява нови и редактирани данни
- Предоставя методи за достъп до различни типове данни

```javascript
async getAllTransactions() {
    try {
        // Извличане на броя транзакции
        const { count, error: countError } = await this.supabase
            .from(this.tableName)
            .select('*', { count: 'exact', head: true });
            
        // Определяне на пагинация
        const pageSize = 1000;
        const pages = Math.ceil(count / pageSize);
        
        // Извличане на данни по страници
        let allTransactions = [];
        for (let page = 0; page < pages; page++) {
            const offset = page * pageSize;
            const { data, error } = await this.supabase
                .from(this.tableName)
                .select('*')
                .range(offset, offset + pageSize - 1);
                
            // Обработка на резултата
            // ...
        }
        
        return allTransactions;
    } catch (error) {
        // Обработка на грешки
    }
}
```

## Потребителски интерфейс

### Основни компоненти на UI

1. **Обобщен панел (Summary)**
   - Показва общ брой транзакции
   - Показва обща сума на транзакциите
   - Показва средна сума на транзакциите

2. **Филтри**
   - Филтри за период (от дата - до дата)
   - Филтър за валута
   - Филтър за тип транзакция
   - Бързи филтри (последна седмица, месец, и т.н.)

3. **Таблица с търговци**
   - Списък на всички търговци
   - Общ брой транзакции за всеки търговец
   - Обща и средна сума за всеки търговец

4. **Графики**
   - Кръгова графика за разпределение по търговци
   - Кръгова графика за разпределение по категории

5. **Таблица с транзакции**
   - Детайлна информация за всички транзакции
   - Филтриране по избран търговец
   - Опция за изтриване на транзакция

6. **Секция с категории**
   - Управление на категории (добавяне, редактиране, изтриване)
   - Асоцииране на търговци с категории
   - Визуализация на разходите по категории

### Потребителски поток

1. **Зареждане на данни**
   - Потребителят отваря приложението
   - Данните се зареждат автоматично
   - Показват се обобщен панел, графики и таблица с търговци

2. **Филтриране на данни**
   - Потребителят задава филтри (период, валута, тип)
   - Приложението обновява всички компоненти според филтрите
   - Потребителят може да използва бързи филтри за стандартни периоди

3. **Преглед на детайли**
   - Потребителят избира търговец от таблицата
   - Показват се детайлни транзакции за избрания търговец
   - Потребителят може да изтрие транзакция при необходимост

4. **Управление на категории**
   - Потребителят превключва към таб "Категории"
   - Може да създава, редактира и изтрива категории
   - Може да асоциира търговци с категории за по-добра организация

5. **Импортиране на данни**
   - Потребителят импортира CSV файл с транзакции
   - Приложението обработва данните и ги добавя към съществуващите
   - Автоматично се актуализират всички компоненти с новите данни

## Технически детайли

### Събития и слушатели

Основната комуникация между компонентите се осъществява чрез:
1. **Директни извиквания на методи** - когато компонентите са тясно свързани
2. **Callback функции** - предавани при инициализацията на компонентите
3. **DOM събития** - за реакция на потребителски действия

Примери за ключови събития:
- Промяна на филтри → обновяване на графика и таблици
- Импортиране на CSV → обновяване на данните и UI компонентите
- Избор на търговец → показване на специфични транзакции

### Обработка на данни

1. **Групиране на транзакции**
```javascript
static groupTransactionsByMerchant(transactions) {
    const merchantsMap = {};
    
    transactions.forEach(transaction => {
        const merchantName = transaction.Description || 'Неизвестен';
        const amount = parseFloat(transaction.Amount) || 0;

        if (!merchantsMap[merchantName]) {
            merchantsMap[merchantName] = {
                name: merchantName,
                count: 0,
                totalAmount: 0,
                transactions: []
            };
        }

        merchantsMap[merchantName].count += 1;
        merchantsMap[merchantName].totalAmount += amount;
        merchantsMap[merchantName].transactions.push(transaction);
    });

    return Object.values(merchantsMap);
}
```

2. **Филтриране на транзакции**
```javascript
filterTransactionsLocally(transactions, filters) {
    return transactions.filter(transaction => {
        // Проверка на дата, валута, тип и т.н.
        // ...
        return keepTransaction;
    });
}
```

### Среди на изпълнение

Приложението поддържа различни среди:
- **Development** - Локална разработка с HTTP сървър
- **Production** - Публикувана версия с реални данни

## Бъдещо развитие

### Планирани функционалности

1. **Подобрена категоризация**
   - Автоматична категоризация на транзакции
   - Предложения за категории базирани на подобни транзакции

2. **Разширени анализи**
   - Тенденции на разходите във времето
   - Предвиждане на бъдещи разходи
   - Бюджетиране и следене на бюджет

3. **Мобилна оптимизация**
   - Адаптивен дизайн за мобилни устройства
   - Локално съхранение на данни за офлайн достъп

4. **Интеграция**
   - Поддръжка на други формати за импорт
   - Интеграция с други финансови инструменти

### Технически подобрения

1. **Оптимизация на производителността**
   - Индексиране на данни за по-бързо филтриране
   - Кеширане на често използвани заявки

2. **Сигурност**
   - Подобряване на обработката на чувствителни данни
   - Имплементиране на автентикация за потребителите

3. **Тестване**
   - Разработване на модулни тестове
   - Автоматизирано тестване на UI компоненти

## Заключение

Архитектурата на приложението е проектирана да бъде модулна, разширяема и поддържаема. Ясното разделение на отговорностите и добре дефинираните интерфейси между компонентите позволяват лесно добавяне на нови функционалности и поддръжка на съществуващите. Приложението използва съвременни уеб технологии и следва добрите практики за разработка на софтуер.